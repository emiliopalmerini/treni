// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delay_records.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const getDelayRecordsByDateRange = `-- name: GetDelayRecordsByDateRange :many
SELECT id, train_number, train_category, origin, destination, date, delay, cancelled, source, recorded_at FROM delay_records
WHERE date BETWEEN ? AND ?
ORDER BY date DESC, train_number
`

type GetDelayRecordsByDateRangeParams struct {
	FromDate time.Time `json:"from_date"`
	ToDate   time.Time `json:"to_date"`
}

func (q *Queries) GetDelayRecordsByDateRange(ctx context.Context, arg GetDelayRecordsByDateRangeParams) ([]DelayRecord, error) {
	rows, err := q.db.QueryContext(ctx, getDelayRecordsByDateRange, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelayRecord{}
	for rows.Next() {
		var i DelayRecord
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.Origin,
			&i.Destination,
			&i.Date,
			&i.Delay,
			&i.Cancelled,
			&i.Source,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelayRecordsByTrain = `-- name: GetDelayRecordsByTrain :many
SELECT id, train_number, train_category, origin, destination, date, delay, cancelled, source, recorded_at FROM delay_records
WHERE train_number = ?
ORDER BY date DESC
`

func (q *Queries) GetDelayRecordsByTrain(ctx context.Context, trainNumber string) ([]DelayRecord, error) {
	rows, err := q.db.QueryContext(ctx, getDelayRecordsByTrain, trainNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelayRecord{}
	for rows.Next() {
		var i DelayRecord
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.Origin,
			&i.Destination,
			&i.Date,
			&i.Delay,
			&i.Cancelled,
			&i.Source,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelayRecordsByTrainInRange = `-- name: GetDelayRecordsByTrainInRange :many
SELECT id, train_number, train_category, origin, destination, date, delay, cancelled, source, recorded_at FROM delay_records
WHERE train_number = ?
AND date BETWEEN ? AND ?
ORDER BY date DESC
`

func (q *Queries) GetDelayRecordsByTrainInRange(ctx context.Context, trainNumber string) ([]DelayRecord, error) {
	rows, err := q.db.QueryContext(ctx, getDelayRecordsByTrainInRange, trainNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelayRecord{}
	for rows.Next() {
		var i DelayRecord
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.Origin,
			&i.Destination,
			&i.Date,
			&i.Delay,
			&i.Cancelled,
			&i.Source,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostDelayedTrains = `-- name: GetMostDelayedTrains :many
SELECT
    train_number,
    train_category,
    origin,
    destination,
    COUNT(*) as trip_count,
    AVG(delay) as avg_delay,
    MAX(delay) as max_delay
FROM delay_records
WHERE date BETWEEN ? AND ?
AND cancelled = FALSE
GROUP BY train_number, train_category, origin, destination
ORDER BY avg_delay DESC
LIMIT ?
`

type GetMostDelayedTrainsParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	Limit  int64     `json:"limit"`
}

type GetMostDelayedTrainsRow struct {
	TrainNumber   string          `json:"train_number"`
	TrainCategory sql.NullString  `json:"train_category"`
	Origin        string          `json:"origin"`
	Destination   string          `json:"destination"`
	TripCount     int64           `json:"trip_count"`
	AvgDelay      sql.NullFloat64 `json:"avg_delay"`
	MaxDelay      interface{}     `json:"max_delay"`
}

func (q *Queries) GetMostDelayedTrains(ctx context.Context, arg GetMostDelayedTrainsParams) ([]GetMostDelayedTrainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostDelayedTrains, arg.Date, arg.Date_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostDelayedTrainsRow{}
	for rows.Next() {
		var i GetMostDelayedTrainsRow
		if err := rows.Scan(
			&i.TrainNumber,
			&i.TrainCategory,
			&i.Origin,
			&i.Destination,
			&i.TripCount,
			&i.AvgDelay,
			&i.MaxDelay,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostReliableTrains = `-- name: GetMostReliableTrains :many
SELECT
    train_number,
    train_category,
    origin,
    destination,
    COUNT(*) as trip_count,
    AVG(delay) as avg_delay,
    SUM(CASE WHEN delay <= 5 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_rate
FROM delay_records
WHERE date BETWEEN ? AND ?
AND cancelled = FALSE
GROUP BY train_number, train_category, origin, destination
HAVING COUNT(*) >= 5
ORDER BY on_time_rate DESC, avg_delay ASC
LIMIT ?
`

type GetMostReliableTrainsParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
	Limit  int64     `json:"limit"`
}

type GetMostReliableTrainsRow struct {
	TrainNumber   string          `json:"train_number"`
	TrainCategory sql.NullString  `json:"train_category"`
	Origin        string          `json:"origin"`
	Destination   string          `json:"destination"`
	TripCount     int64           `json:"trip_count"`
	AvgDelay      sql.NullFloat64 `json:"avg_delay"`
	OnTimeRate    int64           `json:"on_time_rate"`
}

func (q *Queries) GetMostReliableTrains(ctx context.Context, arg GetMostReliableTrainsParams) ([]GetMostReliableTrainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostReliableTrains, arg.Date, arg.Date_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostReliableTrainsRow{}
	for rows.Next() {
		var i GetMostReliableTrainsRow
		if err := rows.Scan(
			&i.TrainNumber,
			&i.TrainCategory,
			&i.Origin,
			&i.Destination,
			&i.TripCount,
			&i.AvgDelay,
			&i.OnTimeRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainStats = `-- name: GetTrainStats :one
SELECT
    train_number,
    COUNT(*) as total_trips,
    SUM(CASE WHEN delay <= 5 AND cancelled = FALSE THEN 1 ELSE 0 END) as on_time_trips,
    SUM(CASE WHEN delay > 5 AND cancelled = FALSE THEN 1 ELSE 0 END) as delayed_trips,
    SUM(CASE WHEN cancelled = TRUE THEN 1 ELSE 0 END) as cancelled_trips,
    AVG(CASE WHEN cancelled = FALSE THEN delay ELSE NULL END) as average_delay,
    MAX(CASE WHEN cancelled = FALSE THEN delay ELSE NULL END) as max_delay
FROM delay_records
WHERE train_number = ?
AND date BETWEEN ? AND ?
GROUP BY train_number
`

type GetTrainStatsRow struct {
	TrainNumber    string          `json:"train_number"`
	TotalTrips     int64           `json:"total_trips"`
	OnTimeTrips    sql.NullFloat64 `json:"on_time_trips"`
	DelayedTrips   sql.NullFloat64 `json:"delayed_trips"`
	CancelledTrips sql.NullFloat64 `json:"cancelled_trips"`
	AverageDelay   sql.NullFloat64 `json:"average_delay"`
	MaxDelay       interface{}     `json:"max_delay"`
}

func (q *Queries) GetTrainStats(ctx context.Context, trainNumber string) (GetTrainStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainStats, trainNumber)
	var i GetTrainStatsRow
	err := row.Scan(
		&i.TrainNumber,
		&i.TotalTrips,
		&i.OnTimeTrips,
		&i.DelayedTrips,
		&i.CancelledTrips,
		&i.AverageDelay,
		&i.MaxDelay,
	)
	return i, err
}

const insertDelayRecord = `-- name: InsertDelayRecord :exec
INSERT INTO delay_records (train_number, train_category, origin, destination, date, delay, cancelled, source)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(train_number, date, source) DO UPDATE SET
    delay = excluded.delay,
    cancelled = excluded.cancelled,
    recorded_at = CURRENT_TIMESTAMP
`

type InsertDelayRecordParams struct {
	TrainNumber   string         `json:"train_number"`
	TrainCategory sql.NullString `json:"train_category"`
	Origin        string         `json:"origin"`
	Destination   string         `json:"destination"`
	Date          time.Time      `json:"date"`
	Delay         int64          `json:"delay"`
	Cancelled     sql.NullBool   `json:"cancelled"`
	Source        sql.NullString `json:"source"`
}

func (q *Queries) InsertDelayRecord(ctx context.Context, arg InsertDelayRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertDelayRecord,
		arg.TrainNumber,
		arg.TrainCategory,
		arg.Origin,
		arg.Destination,
		arg.Date,
		arg.Delay,
		arg.Cancelled,
		arg.Source,
	)
	return err
}
