// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: station.sql

package sqlc

import (
	"context"
	"time"
)

const countStations = `-- name: CountStations :one
SELECT COUNT(*) FROM station
`

func (q *Queries) CountStations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStation = `-- name: CreateStation :exec
INSERT INTO station (id, name, region, latitude, longitude, updated_at)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateStationParams struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) CreateStation(ctx context.Context, arg CreateStationParams) error {
	_, err := q.db.ExecContext(ctx, createStation,
		arg.ID,
		arg.Name,
		arg.Region,
		arg.Latitude,
		arg.Longitude,
		arg.UpdatedAt,
	)
	return err
}

const deleteStation = `-- name: DeleteStation :exec
DELETE FROM station WHERE id = ?
`

func (q *Queries) DeleteStation(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteStation, id)
	return err
}

const getStationByID = `-- name: GetStationByID :one
SELECT id, name, region, latitude, longitude, updated_at
FROM station WHERE id = ?
`

type GetStationByIDRow struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) GetStationByID(ctx context.Context, id string) (GetStationByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStationByID, id)
	var i GetStationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Region,
		&i.Latitude,
		&i.Longitude,
		&i.UpdatedAt,
	)
	return i, err
}

const listStations = `-- name: ListStations :many
SELECT id, name, region, latitude, longitude, updated_at
FROM station ORDER BY name
`

type ListStationsRow struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) ListStations(ctx context.Context) ([]ListStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listStations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStationsRow{}
	for rows.Next() {
		var i ListStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStationsWithCoordinates = `-- name: ListStationsWithCoordinates :many
SELECT id, name, region, latitude, longitude, updated_at
FROM station WHERE latitude != 0 AND longitude != 0
`

type ListStationsWithCoordinatesRow struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) ListStationsWithCoordinates(ctx context.Context) ([]ListStationsWithCoordinatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listStationsWithCoordinates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStationsWithCoordinatesRow{}
	for rows.Next() {
		var i ListStationsWithCoordinatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStations = `-- name: SearchStations :many
SELECT id, name, region, latitude, longitude, updated_at
FROM station WHERE name LIKE ? ORDER BY name LIMIT 20
`

type SearchStationsRow struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) SearchStations(ctx context.Context, name string) ([]SearchStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchStations, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchStationsRow{}
	for rows.Next() {
		var i SearchStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Region,
			&i.Latitude,
			&i.Longitude,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStation = `-- name: UpdateStation :exec
UPDATE station SET name = ?, region = ?, latitude = ?, longitude = ?, updated_at = ?
WHERE id = ?
`

type UpdateStationParams struct {
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
	ID        string     `json:"id"`
}

func (q *Queries) UpdateStation(ctx context.Context, arg UpdateStationParams) error {
	_, err := q.db.ExecContext(ctx, updateStation,
		arg.Name,
		arg.Region,
		arg.Latitude,
		arg.Longitude,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const upsertStation = `-- name: UpsertStation :exec
INSERT INTO station (id, name, region, latitude, longitude, updated_at)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    region = excluded.region,
    latitude = excluded.latitude,
    longitude = excluded.longitude,
    updated_at = excluded.updated_at
`

type UpsertStationParams struct {
	ID        string     `json:"id"`
	Name      string     `json:"name"`
	Region    *int64     `json:"region"`
	Latitude  *float64   `json:"latitude"`
	Longitude *float64   `json:"longitude"`
	UpdatedAt *time.Time `json:"updated_at"`
}

func (q *Queries) UpsertStation(ctx context.Context, arg UpsertStationParams) error {
	_, err := q.db.ExecContext(ctx, upsertStation,
		arg.ID,
		arg.Name,
		arg.Region,
		arg.Latitude,
		arg.Longitude,
		arg.UpdatedAt,
	)
	return err
}
