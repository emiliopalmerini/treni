// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: voyage.sql

package sqlc

import (
	"context"
	"time"
)

const createVoyage = `-- name: CreateVoyage :exec

INSERT INTO voyage (id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateVoyageParams struct {
	ID                 string    `json:"id"`
	TrainNumber        int64     `json:"train_number"`
	TrainCategory      *string   `json:"train_category"`
	OriginID           string    `json:"origin_id"`
	OriginName         string    `json:"origin_name"`
	DestinationID      string    `json:"destination_id"`
	DestinationName    string    `json:"destination_name"`
	ScheduledDate      string    `json:"scheduled_date"`
	ScheduledDeparture time.Time `json:"scheduled_departure"`
	CirculationState   *int64    `json:"circulation_state"`
	CreatedAt          time.Time `json:"created_at"`
	UpdatedAt          time.Time `json:"updated_at"`
}

// Voyage CRUD operations
func (q *Queries) CreateVoyage(ctx context.Context, arg CreateVoyageParams) error {
	_, err := q.db.ExecContext(ctx, createVoyage,
		arg.ID,
		arg.TrainNumber,
		arg.TrainCategory,
		arg.OriginID,
		arg.OriginName,
		arg.DestinationID,
		arg.DestinationName,
		arg.ScheduledDate,
		arg.ScheduledDeparture,
		arg.CirculationState,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createVoyageStop = `-- name: CreateVoyageStop :exec

INSERT INTO voyage_stop (id, voyage_id, station_id, station_name, stop_sequence,
    stop_type, scheduled_arrival, scheduled_departure, actual_arrival, actual_departure,
    arrival_delay, departure_delay, platform, is_suppressed, last_observation_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateVoyageStopParams struct {
	ID                 string     `json:"id"`
	VoyageID           string     `json:"voyage_id"`
	StationID          string     `json:"station_id"`
	StationName        string     `json:"station_name"`
	StopSequence       int64      `json:"stop_sequence"`
	StopType           *string    `json:"stop_type"`
	ScheduledArrival   *time.Time `json:"scheduled_arrival"`
	ScheduledDeparture *time.Time `json:"scheduled_departure"`
	ActualArrival      *time.Time `json:"actual_arrival"`
	ActualDeparture    *time.Time `json:"actual_departure"`
	ArrivalDelay       *int64     `json:"arrival_delay"`
	DepartureDelay     *int64     `json:"departure_delay"`
	Platform           *string    `json:"platform"`
	IsSuppressed       *int64     `json:"is_suppressed"`
	LastObservationAt  *time.Time `json:"last_observation_at"`
}

// Voyage Stop CRUD operations
func (q *Queries) CreateVoyageStop(ctx context.Context, arg CreateVoyageStopParams) error {
	_, err := q.db.ExecContext(ctx, createVoyageStop,
		arg.ID,
		arg.VoyageID,
		arg.StationID,
		arg.StationName,
		arg.StopSequence,
		arg.StopType,
		arg.ScheduledArrival,
		arg.ScheduledDeparture,
		arg.ActualArrival,
		arg.ActualDeparture,
		arg.ArrivalDelay,
		arg.DepartureDelay,
		arg.Platform,
		arg.IsSuppressed,
		arg.LastObservationAt,
	)
	return err
}

const findVoyageByKey = `-- name: FindVoyageByKey :one
SELECT id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at
FROM voyage
WHERE train_number = ? AND origin_id = ? AND scheduled_date = ?
LIMIT 1
`

type FindVoyageByKeyParams struct {
	TrainNumber   int64  `json:"train_number"`
	OriginID      string `json:"origin_id"`
	ScheduledDate string `json:"scheduled_date"`
}

func (q *Queries) FindVoyageByKey(ctx context.Context, arg FindVoyageByKeyParams) (Voyage, error) {
	row := q.db.QueryRowContext(ctx, findVoyageByKey, arg.TrainNumber, arg.OriginID, arg.ScheduledDate)
	var i Voyage
	err := row.Scan(
		&i.ID,
		&i.TrainNumber,
		&i.TrainCategory,
		&i.OriginID,
		&i.OriginName,
		&i.DestinationID,
		&i.DestinationName,
		&i.ScheduledDate,
		&i.ScheduledDeparture,
		&i.CirculationState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVoyageStopByStation = `-- name: FindVoyageStopByStation :one
SELECT id, voyage_id, station_id, station_name, stop_sequence,
    stop_type, scheduled_arrival, scheduled_departure, actual_arrival, actual_departure,
    arrival_delay, departure_delay, platform, is_suppressed, last_observation_at
FROM voyage_stop
WHERE voyage_id = ? AND station_id = ?
LIMIT 1
`

type FindVoyageStopByStationParams struct {
	VoyageID  string `json:"voyage_id"`
	StationID string `json:"station_id"`
}

func (q *Queries) FindVoyageStopByStation(ctx context.Context, arg FindVoyageStopByStationParams) (VoyageStop, error) {
	row := q.db.QueryRowContext(ctx, findVoyageStopByStation, arg.VoyageID, arg.StationID)
	var i VoyageStop
	err := row.Scan(
		&i.ID,
		&i.VoyageID,
		&i.StationID,
		&i.StationName,
		&i.StopSequence,
		&i.StopType,
		&i.ScheduledArrival,
		&i.ScheduledDeparture,
		&i.ActualArrival,
		&i.ActualDeparture,
		&i.ArrivalDelay,
		&i.DepartureDelay,
		&i.Platform,
		&i.IsSuppressed,
		&i.LastObservationAt,
	)
	return i, err
}

const getRecentVoyages = `-- name: GetRecentVoyages :many
SELECT id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at
FROM voyage
ORDER BY updated_at DESC
LIMIT ?
`

func (q *Queries) GetRecentVoyages(ctx context.Context, limit int64) ([]Voyage, error) {
	rows, err := q.db.QueryContext(ctx, getRecentVoyages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voyage{}
	for rows.Next() {
		var i Voyage
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledDate,
			&i.ScheduledDeparture,
			&i.CirculationState,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationStatsFromVoyages = `-- name: GetStationStatsFromVoyages :one
SELECT
    COUNT(*) as observation_count,
    COALESCE(AVG(COALESCE(arrival_delay, departure_delay)), 0) as average_delay,
    SUM(CASE WHEN COALESCE(arrival_delay, departure_delay) = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage,
    SUM(CASE WHEN is_suppressed = 1 THEN 1 ELSE 0 END) as suppressed_count
FROM voyage_stop
WHERE station_id = ?
  AND last_observation_at IS NOT NULL
`

type GetStationStatsFromVoyagesRow struct {
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
	SuppressedCount  *float64    `json:"suppressed_count"`
}

func (q *Queries) GetStationStatsFromVoyages(ctx context.Context, stationID string) (GetStationStatsFromVoyagesRow, error) {
	row := q.db.QueryRowContext(ctx, getStationStatsFromVoyages, stationID)
	var i GetStationStatsFromVoyagesRow
	err := row.Scan(
		&i.ObservationCount,
		&i.AverageDelay,
		&i.OnTimePercentage,
		&i.SuppressedCount,
	)
	return i, err
}

const getStationStopsFromVoyages = `-- name: GetStationStopsFromVoyages :many
SELECT
    v.id as voyage_id,
    v.train_number,
    v.train_category,
    v.origin_name,
    v.destination_name,
    v.scheduled_date,
    vs.arrival_delay,
    vs.departure_delay,
    vs.scheduled_arrival,
    vs.scheduled_departure,
    vs.actual_arrival,
    vs.actual_departure,
    vs.is_suppressed
FROM voyage_stop vs
JOIN voyage v ON vs.voyage_id = v.id
WHERE vs.station_id = ?
  AND vs.last_observation_at IS NOT NULL
ORDER BY v.scheduled_date DESC, vs.scheduled_arrival DESC
LIMIT ?
`

type GetStationStopsFromVoyagesParams struct {
	StationID string `json:"station_id"`
	Limit     int64  `json:"limit"`
}

type GetStationStopsFromVoyagesRow struct {
	VoyageID           string     `json:"voyage_id"`
	TrainNumber        int64      `json:"train_number"`
	TrainCategory      *string    `json:"train_category"`
	OriginName         string     `json:"origin_name"`
	DestinationName    string     `json:"destination_name"`
	ScheduledDate      string     `json:"scheduled_date"`
	ArrivalDelay       *int64     `json:"arrival_delay"`
	DepartureDelay     *int64     `json:"departure_delay"`
	ScheduledArrival   *time.Time `json:"scheduled_arrival"`
	ScheduledDeparture *time.Time `json:"scheduled_departure"`
	ActualArrival      *time.Time `json:"actual_arrival"`
	ActualDeparture    *time.Time `json:"actual_departure"`
	IsSuppressed       *int64     `json:"is_suppressed"`
}

func (q *Queries) GetStationStopsFromVoyages(ctx context.Context, arg GetStationStopsFromVoyagesParams) ([]GetStationStopsFromVoyagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationStopsFromVoyages, arg.StationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStationStopsFromVoyagesRow{}
	for rows.Next() {
		var i GetStationStopsFromVoyagesRow
		if err := rows.Scan(
			&i.VoyageID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginName,
			&i.DestinationName,
			&i.ScheduledDate,
			&i.ArrivalDelay,
			&i.DepartureDelay,
			&i.ScheduledArrival,
			&i.ScheduledDeparture,
			&i.ActualArrival,
			&i.ActualDeparture,
			&i.IsSuppressed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoyageByID = `-- name: GetVoyageByID :one
SELECT id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at
FROM voyage
WHERE id = ?
`

func (q *Queries) GetVoyageByID(ctx context.Context, id string) (Voyage, error) {
	row := q.db.QueryRowContext(ctx, getVoyageByID, id)
	var i Voyage
	err := row.Scan(
		&i.ID,
		&i.TrainNumber,
		&i.TrainCategory,
		&i.OriginID,
		&i.OriginName,
		&i.DestinationID,
		&i.DestinationName,
		&i.ScheduledDate,
		&i.ScheduledDeparture,
		&i.CirculationState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoyageDelayProgression = `-- name: GetVoyageDelayProgression :many

SELECT stop_sequence, station_name, scheduled_arrival, scheduled_departure,
    actual_arrival, actual_departure, arrival_delay, departure_delay, is_suppressed
FROM voyage_stop
WHERE voyage_id = ?
ORDER BY stop_sequence ASC
`

type GetVoyageDelayProgressionRow struct {
	StopSequence       int64      `json:"stop_sequence"`
	StationName        string     `json:"station_name"`
	ScheduledArrival   *time.Time `json:"scheduled_arrival"`
	ScheduledDeparture *time.Time `json:"scheduled_departure"`
	ActualArrival      *time.Time `json:"actual_arrival"`
	ActualDeparture    *time.Time `json:"actual_departure"`
	ArrivalDelay       *int64     `json:"arrival_delay"`
	DepartureDelay     *int64     `json:"departure_delay"`
	IsSuppressed       *int64     `json:"is_suppressed"`
}

// Voyage statistics and queries
func (q *Queries) GetVoyageDelayProgression(ctx context.Context, voyageID string) ([]GetVoyageDelayProgressionRow, error) {
	rows, err := q.db.QueryContext(ctx, getVoyageDelayProgression, voyageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVoyageDelayProgressionRow{}
	for rows.Next() {
		var i GetVoyageDelayProgressionRow
		if err := rows.Scan(
			&i.StopSequence,
			&i.StationName,
			&i.ScheduledArrival,
			&i.ScheduledDeparture,
			&i.ActualArrival,
			&i.ActualDeparture,
			&i.ArrivalDelay,
			&i.DepartureDelay,
			&i.IsSuppressed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoyageStops = `-- name: GetVoyageStops :many
SELECT id, voyage_id, station_id, station_name, stop_sequence,
    stop_type, scheduled_arrival, scheduled_departure, actual_arrival, actual_departure,
    arrival_delay, departure_delay, platform, is_suppressed, last_observation_at
FROM voyage_stop
WHERE voyage_id = ?
ORDER BY stop_sequence ASC
`

func (q *Queries) GetVoyageStops(ctx context.Context, voyageID string) ([]VoyageStop, error) {
	rows, err := q.db.QueryContext(ctx, getVoyageStops, voyageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VoyageStop{}
	for rows.Next() {
		var i VoyageStop
		if err := rows.Scan(
			&i.ID,
			&i.VoyageID,
			&i.StationID,
			&i.StationName,
			&i.StopSequence,
			&i.StopType,
			&i.ScheduledArrival,
			&i.ScheduledDeparture,
			&i.ActualArrival,
			&i.ActualDeparture,
			&i.ArrivalDelay,
			&i.DepartureDelay,
			&i.Platform,
			&i.IsSuppressed,
			&i.LastObservationAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoyagesByDate = `-- name: GetVoyagesByDate :many
SELECT id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at
FROM voyage
WHERE scheduled_date = ?
ORDER BY scheduled_departure ASC
LIMIT ?
`

type GetVoyagesByDateParams struct {
	ScheduledDate string `json:"scheduled_date"`
	Limit         int64  `json:"limit"`
}

func (q *Queries) GetVoyagesByDate(ctx context.Context, arg GetVoyagesByDateParams) ([]Voyage, error) {
	rows, err := q.db.QueryContext(ctx, getVoyagesByDate, arg.ScheduledDate, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voyage{}
	for rows.Next() {
		var i Voyage
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledDate,
			&i.ScheduledDeparture,
			&i.CirculationState,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoyagesByStation = `-- name: GetVoyagesByStation :many
SELECT DISTINCT v.id, v.train_number, v.train_category, v.origin_id, v.origin_name,
    v.destination_id, v.destination_name, v.scheduled_date, v.scheduled_departure,
    v.circulation_state, v.created_at, v.updated_at
FROM voyage v
JOIN voyage_stop vs ON v.id = vs.voyage_id
WHERE vs.station_id = ?
  AND vs.last_observation_at IS NOT NULL
ORDER BY v.scheduled_date DESC, v.scheduled_departure DESC
LIMIT ?
`

type GetVoyagesByStationParams struct {
	StationID string `json:"station_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetVoyagesByStation(ctx context.Context, arg GetVoyagesByStationParams) ([]Voyage, error) {
	rows, err := q.db.QueryContext(ctx, getVoyagesByStation, arg.StationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voyage{}
	for rows.Next() {
		var i Voyage
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledDate,
			&i.ScheduledDeparture,
			&i.CirculationState,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoyagesByTrain = `-- name: GetVoyagesByTrain :many
SELECT id, train_number, train_category, origin_id, origin_name,
    destination_id, destination_name, scheduled_date, scheduled_departure,
    circulation_state, created_at, updated_at
FROM voyage
WHERE train_number = ?
ORDER BY scheduled_date DESC, scheduled_departure DESC
LIMIT ?
`

type GetVoyagesByTrainParams struct {
	TrainNumber int64 `json:"train_number"`
	Limit       int64 `json:"limit"`
}

func (q *Queries) GetVoyagesByTrain(ctx context.Context, arg GetVoyagesByTrainParams) ([]Voyage, error) {
	rows, err := q.db.QueryContext(ctx, getVoyagesByTrain, arg.TrainNumber, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Voyage{}
	for rows.Next() {
		var i Voyage
		if err := rows.Scan(
			&i.ID,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledDate,
			&i.ScheduledDeparture,
			&i.CirculationState,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObservationVoyageStopLink = `-- name: UpdateObservationVoyageStopLink :exec
UPDATE train_observation
SET voyage_stop_id = ?
WHERE id = ?
`

type UpdateObservationVoyageStopLinkParams struct {
	VoyageStopID *string `json:"voyage_stop_id"`
	ID           string  `json:"id"`
}

func (q *Queries) UpdateObservationVoyageStopLink(ctx context.Context, arg UpdateObservationVoyageStopLinkParams) error {
	_, err := q.db.ExecContext(ctx, updateObservationVoyageStopLink, arg.VoyageStopID, arg.ID)
	return err
}

const updateVoyage = `-- name: UpdateVoyage :exec
UPDATE voyage
SET train_category = ?,
    circulation_state = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateVoyageParams struct {
	TrainCategory    *string   `json:"train_category"`
	CirculationState *int64    `json:"circulation_state"`
	UpdatedAt        time.Time `json:"updated_at"`
	ID               string    `json:"id"`
}

func (q *Queries) UpdateVoyage(ctx context.Context, arg UpdateVoyageParams) error {
	_, err := q.db.ExecContext(ctx, updateVoyage,
		arg.TrainCategory,
		arg.CirculationState,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateVoyageStop = `-- name: UpdateVoyageStop :exec
UPDATE voyage_stop
SET actual_arrival = ?,
    actual_departure = ?,
    arrival_delay = ?,
    departure_delay = ?,
    platform = ?,
    is_suppressed = ?,
    last_observation_at = ?
WHERE id = ?
`

type UpdateVoyageStopParams struct {
	ActualArrival     *time.Time `json:"actual_arrival"`
	ActualDeparture   *time.Time `json:"actual_departure"`
	ArrivalDelay      *int64     `json:"arrival_delay"`
	DepartureDelay    *int64     `json:"departure_delay"`
	Platform          *string    `json:"platform"`
	IsSuppressed      *int64     `json:"is_suppressed"`
	LastObservationAt *time.Time `json:"last_observation_at"`
	ID                string     `json:"id"`
}

func (q *Queries) UpdateVoyageStop(ctx context.Context, arg UpdateVoyageStopParams) error {
	_, err := q.db.ExecContext(ctx, updateVoyageStop,
		arg.ActualArrival,
		arg.ActualDeparture,
		arg.ArrivalDelay,
		arg.DepartureDelay,
		arg.Platform,
		arg.IsSuppressed,
		arg.LastObservationAt,
		arg.ID,
	)
	return err
}
