// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: observation.sql

package sqlc

import (
	"context"
	"time"
)

const createObservation = `-- name: CreateObservation :exec
INSERT INTO train_observation (id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, delay, platform, circulation_state)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateObservationParams struct {
	ID               string     `json:"id"`
	ObservedAt       time.Time  `json:"observed_at"`
	StationID        string     `json:"station_id"`
	StationName      string     `json:"station_name"`
	ObservationType  string     `json:"observation_type"`
	TrainNumber      int64      `json:"train_number"`
	TrainCategory    *string    `json:"train_category"`
	OriginID         *string    `json:"origin_id"`
	OriginName       *string    `json:"origin_name"`
	DestinationID    *string    `json:"destination_id"`
	DestinationName  *string    `json:"destination_name"`
	ScheduledTime    *time.Time `json:"scheduled_time"`
	Delay            *int64     `json:"delay"`
	Platform         *string    `json:"platform"`
	CirculationState *int64     `json:"circulation_state"`
}

func (q *Queries) CreateObservation(ctx context.Context, arg CreateObservationParams) error {
	_, err := q.db.ExecContext(ctx, createObservation,
		arg.ID,
		arg.ObservedAt,
		arg.StationID,
		arg.StationName,
		arg.ObservationType,
		arg.TrainNumber,
		arg.TrainCategory,
		arg.OriginID,
		arg.OriginName,
		arg.DestinationID,
		arg.DestinationName,
		arg.ScheduledTime,
		arg.Delay,
		arg.Platform,
		arg.CirculationState,
	)
	return err
}

const getGlobalStats = `-- name: GetGlobalStats :one
SELECT
    COUNT(*) as total_observations,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) as on_time_count,
    SUM(CASE WHEN circulation_state = 1 THEN 1 ELSE 0 END) as cancelled_count
FROM train_observation
`

type GetGlobalStatsRow struct {
	TotalObservations int64       `json:"total_observations"`
	AverageDelay      interface{} `json:"average_delay"`
	OnTimeCount       *float64    `json:"on_time_count"`
	CancelledCount    *float64    `json:"cancelled_count"`
}

func (q *Queries) GetGlobalStats(ctx context.Context) (GetGlobalStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalStats)
	var i GetGlobalStatsRow
	err := row.Scan(
		&i.TotalObservations,
		&i.AverageDelay,
		&i.OnTimeCount,
		&i.CancelledCount,
	)
	return i, err
}

const getRecentObservations = `-- name: GetRecentObservations :many
SELECT id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, delay, platform, circulation_state
FROM train_observation
ORDER BY observed_at DESC
LIMIT ?
`

func (q *Queries) GetRecentObservations(ctx context.Context, limit int64) ([]TrainObservation, error) {
	rows, err := q.db.QueryContext(ctx, getRecentObservations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrainObservation{}
	for rows.Next() {
		var i TrainObservation
		if err := rows.Scan(
			&i.ID,
			&i.ObservedAt,
			&i.StationID,
			&i.StationName,
			&i.ObservationType,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledTime,
			&i.Delay,
			&i.Platform,
			&i.CirculationState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentObservationsByStation = `-- name: GetRecentObservationsByStation :many
SELECT id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, delay, platform, circulation_state
FROM train_observation
WHERE station_id = ?
ORDER BY observed_at DESC
LIMIT ?
`

type GetRecentObservationsByStationParams struct {
	StationID string `json:"station_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetRecentObservationsByStation(ctx context.Context, arg GetRecentObservationsByStationParams) ([]TrainObservation, error) {
	rows, err := q.db.QueryContext(ctx, getRecentObservationsByStation, arg.StationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrainObservation{}
	for rows.Next() {
		var i TrainObservation
		if err := rows.Scan(
			&i.ID,
			&i.ObservedAt,
			&i.StationID,
			&i.StationName,
			&i.ObservationType,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledTime,
			&i.Delay,
			&i.Platform,
			&i.CirculationState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByCategory = `-- name: GetStatsByCategory :many
SELECT
    train_category as category,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE train_category != ''
GROUP BY train_category
ORDER BY observation_count DESC
`

type GetStatsByCategoryRow struct {
	Category         *string     `json:"category"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByCategory(ctx context.Context) ([]GetStatsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatsByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatsByCategoryRow{}
	for rows.Next() {
		var i GetStatsByCategoryRow
		if err := rows.Scan(
			&i.Category,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByStation = `-- name: GetStatsByStation :one
SELECT
    station_id,
    station_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE station_id = ?
GROUP BY station_id
`

type GetStatsByStationRow struct {
	StationID        string      `json:"station_id"`
	StationName      string      `json:"station_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByStation(ctx context.Context, stationID string) (GetStatsByStationRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByStation, stationID)
	var i GetStatsByStationRow
	err := row.Scan(
		&i.StationID,
		&i.StationName,
		&i.ObservationCount,
		&i.AverageDelay,
		&i.OnTimePercentage,
	)
	return i, err
}

const getStatsByTrain = `-- name: GetStatsByTrain :one
SELECT
    train_number,
    train_category as category,
    origin_name,
    destination_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    COALESCE(MAX(delay), 0) as max_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE train_number = ?
GROUP BY train_number
`

type GetStatsByTrainRow struct {
	TrainNumber      int64       `json:"train_number"`
	Category         *string     `json:"category"`
	OriginName       *string     `json:"origin_name"`
	DestinationName  *string     `json:"destination_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	MaxDelay         interface{} `json:"max_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByTrain(ctx context.Context, trainNumber int64) (GetStatsByTrainRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByTrain, trainNumber)
	var i GetStatsByTrainRow
	err := row.Scan(
		&i.TrainNumber,
		&i.Category,
		&i.OriginName,
		&i.DestinationName,
		&i.ObservationCount,
		&i.AverageDelay,
		&i.MaxDelay,
		&i.OnTimePercentage,
	)
	return i, err
}

const getWorstStations = `-- name: GetWorstStations :many
SELECT
    station_id,
    station_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE circulation_state != 1
GROUP BY station_id
HAVING observation_count >= 3
ORDER BY average_delay DESC
LIMIT ?
`

type GetWorstStationsRow struct {
	StationID        string      `json:"station_id"`
	StationName      string      `json:"station_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetWorstStations(ctx context.Context, limit int64) ([]GetWorstStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorstStations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorstStationsRow{}
	for rows.Next() {
		var i GetWorstStationsRow
		if err := rows.Scan(
			&i.StationID,
			&i.StationName,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorstTrains = `-- name: GetWorstTrains :many
SELECT
    train_number,
    train_category as category,
    origin_name,
    destination_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    COALESCE(MAX(delay), 0) as max_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE circulation_state != 1
GROUP BY train_number
HAVING observation_count >= 3
ORDER BY average_delay DESC
LIMIT ?
`

type GetWorstTrainsRow struct {
	TrainNumber      int64       `json:"train_number"`
	Category         *string     `json:"category"`
	OriginName       *string     `json:"origin_name"`
	DestinationName  *string     `json:"destination_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	MaxDelay         interface{} `json:"max_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetWorstTrains(ctx context.Context, limit int64) ([]GetWorstTrainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorstTrains, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorstTrainsRow{}
	for rows.Next() {
		var i GetWorstTrainsRow
		if err := rows.Scan(
			&i.TrainNumber,
			&i.Category,
			&i.OriginName,
			&i.DestinationName,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.MaxDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
