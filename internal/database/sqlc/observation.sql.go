// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: observation.sql

package sqlc

import (
	"context"
	"time"
)

const createDelayVariation = `-- name: CreateDelayVariation :exec
INSERT INTO delay_variation (id, observation_id, recorded_at, delay)
VALUES (?, ?, ?, ?)
`

type CreateDelayVariationParams struct {
	ID            string    `json:"id"`
	ObservationID string    `json:"observation_id"`
	RecordedAt    time.Time `json:"recorded_at"`
	Delay         int64     `json:"delay"`
}

func (q *Queries) CreateDelayVariation(ctx context.Context, arg CreateDelayVariationParams) error {
	_, err := q.db.ExecContext(ctx, createDelayVariation,
		arg.ID,
		arg.ObservationID,
		arg.RecordedAt,
		arg.Delay,
	)
	return err
}

const getDelayVariationsByObservation = `-- name: GetDelayVariationsByObservation :many
SELECT id, observation_id, recorded_at, delay
FROM delay_variation
WHERE observation_id = ?
ORDER BY recorded_at ASC
`

func (q *Queries) GetDelayVariationsByObservation(ctx context.Context, observationID string) ([]DelayVariation, error) {
	rows, err := q.db.QueryContext(ctx, getDelayVariationsByObservation, observationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DelayVariation{}
	for rows.Next() {
		var i DelayVariation
		if err := rows.Scan(
			&i.ID,
			&i.ObservationID,
			&i.RecordedAt,
			&i.Delay,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalStats = `-- name: GetGlobalStats :one
SELECT
    COUNT(*) as total_observations,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) as on_time_count,
    SUM(CASE WHEN circulation_state = 1 THEN 1 ELSE 0 END) as cancelled_count
FROM train_observation
`

type GetGlobalStatsRow struct {
	TotalObservations int64       `json:"total_observations"`
	AverageDelay      interface{} `json:"average_delay"`
	OnTimeCount       *float64    `json:"on_time_count"`
	CancelledCount    *float64    `json:"cancelled_count"`
}

func (q *Queries) GetGlobalStats(ctx context.Context) (GetGlobalStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalStats)
	var i GetGlobalStatsRow
	err := row.Scan(
		&i.TotalObservations,
		&i.AverageDelay,
		&i.OnTimeCount,
		&i.CancelledCount,
	)
	return i, err
}

const getLatestDelayVariation = `-- name: GetLatestDelayVariation :one
SELECT id, observation_id, recorded_at, delay
FROM delay_variation
WHERE observation_id = ?
ORDER BY recorded_at DESC
LIMIT 1
`

func (q *Queries) GetLatestDelayVariation(ctx context.Context, observationID string) (DelayVariation, error) {
	row := q.db.QueryRowContext(ctx, getLatestDelayVariation, observationID)
	var i DelayVariation
	err := row.Scan(
		&i.ID,
		&i.ObservationID,
		&i.RecordedAt,
		&i.Delay,
	)
	return i, err
}

const getObservationByKey = `-- name: GetObservationByKey :one
SELECT id, delay FROM train_observation
WHERE train_number = ? AND station_id = ? AND observation_type = ? AND scheduled_date = ?
`

type GetObservationByKeyParams struct {
	TrainNumber     int64   `json:"train_number"`
	StationID       string  `json:"station_id"`
	ObservationType string  `json:"observation_type"`
	ScheduledDate   *string `json:"scheduled_date"`
}

type GetObservationByKeyRow struct {
	ID    string `json:"id"`
	Delay *int64 `json:"delay"`
}

func (q *Queries) GetObservationByKey(ctx context.Context, arg GetObservationByKeyParams) (GetObservationByKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getObservationByKey,
		arg.TrainNumber,
		arg.StationID,
		arg.ObservationType,
		arg.ScheduledDate,
	)
	var i GetObservationByKeyRow
	err := row.Scan(&i.ID, &i.Delay)
	return i, err
}

const getRecentObservations = `-- name: GetRecentObservations :many
SELECT id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, delay, platform, circulation_state
FROM train_observation
ORDER BY observed_at DESC
LIMIT ?
`

type GetRecentObservationsRow struct {
	ID               string     `json:"id"`
	ObservedAt       time.Time  `json:"observed_at"`
	StationID        string     `json:"station_id"`
	StationName      string     `json:"station_name"`
	ObservationType  string     `json:"observation_type"`
	TrainNumber      int64      `json:"train_number"`
	TrainCategory    *string    `json:"train_category"`
	OriginID         *string    `json:"origin_id"`
	OriginName       *string    `json:"origin_name"`
	DestinationID    *string    `json:"destination_id"`
	DestinationName  *string    `json:"destination_name"`
	ScheduledTime    *time.Time `json:"scheduled_time"`
	Delay            *int64     `json:"delay"`
	Platform         *string    `json:"platform"`
	CirculationState *int64     `json:"circulation_state"`
}

func (q *Queries) GetRecentObservations(ctx context.Context, limit int64) ([]GetRecentObservationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentObservations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentObservationsRow{}
	for rows.Next() {
		var i GetRecentObservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ObservedAt,
			&i.StationID,
			&i.StationName,
			&i.ObservationType,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledTime,
			&i.Delay,
			&i.Platform,
			&i.CirculationState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentObservationsByStation = `-- name: GetRecentObservationsByStation :many
SELECT id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, delay, platform, circulation_state
FROM train_observation
WHERE station_id = ?
ORDER BY observed_at DESC
LIMIT ?
`

type GetRecentObservationsByStationParams struct {
	StationID string `json:"station_id"`
	Limit     int64  `json:"limit"`
}

type GetRecentObservationsByStationRow struct {
	ID               string     `json:"id"`
	ObservedAt       time.Time  `json:"observed_at"`
	StationID        string     `json:"station_id"`
	StationName      string     `json:"station_name"`
	ObservationType  string     `json:"observation_type"`
	TrainNumber      int64      `json:"train_number"`
	TrainCategory    *string    `json:"train_category"`
	OriginID         *string    `json:"origin_id"`
	OriginName       *string    `json:"origin_name"`
	DestinationID    *string    `json:"destination_id"`
	DestinationName  *string    `json:"destination_name"`
	ScheduledTime    *time.Time `json:"scheduled_time"`
	Delay            *int64     `json:"delay"`
	Platform         *string    `json:"platform"`
	CirculationState *int64     `json:"circulation_state"`
}

func (q *Queries) GetRecentObservationsByStation(ctx context.Context, arg GetRecentObservationsByStationParams) ([]GetRecentObservationsByStationRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentObservationsByStation, arg.StationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentObservationsByStationRow{}
	for rows.Next() {
		var i GetRecentObservationsByStationRow
		if err := rows.Scan(
			&i.ID,
			&i.ObservedAt,
			&i.StationID,
			&i.StationName,
			&i.ObservationType,
			&i.TrainNumber,
			&i.TrainCategory,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ScheduledTime,
			&i.Delay,
			&i.Platform,
			&i.CirculationState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByCategory = `-- name: GetStatsByCategory :many
SELECT
    train_category as category,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE train_category != ''
GROUP BY train_category
ORDER BY observation_count DESC
`

type GetStatsByCategoryRow struct {
	Category         *string     `json:"category"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByCategory(ctx context.Context) ([]GetStatsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatsByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatsByCategoryRow{}
	for rows.Next() {
		var i GetStatsByCategoryRow
		if err := rows.Scan(
			&i.Category,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatsByStation = `-- name: GetStatsByStation :one
SELECT
    station_id,
    station_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE station_id = ?
GROUP BY station_id
`

type GetStatsByStationRow struct {
	StationID        string      `json:"station_id"`
	StationName      string      `json:"station_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByStation(ctx context.Context, stationID string) (GetStatsByStationRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByStation, stationID)
	var i GetStatsByStationRow
	err := row.Scan(
		&i.StationID,
		&i.StationName,
		&i.ObservationCount,
		&i.AverageDelay,
		&i.OnTimePercentage,
	)
	return i, err
}

const getStatsByTrain = `-- name: GetStatsByTrain :one
SELECT
    train_number,
    train_category as category,
    origin_id,
    origin_name,
    destination_id,
    destination_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    COALESCE(MAX(delay), 0) as max_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE train_number = ?
GROUP BY train_number, origin_id, destination_id
`

type GetStatsByTrainRow struct {
	TrainNumber      int64       `json:"train_number"`
	Category         *string     `json:"category"`
	OriginID         *string     `json:"origin_id"`
	OriginName       *string     `json:"origin_name"`
	DestinationID    *string     `json:"destination_id"`
	DestinationName  *string     `json:"destination_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	MaxDelay         interface{} `json:"max_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetStatsByTrain(ctx context.Context, trainNumber int64) (GetStatsByTrainRow, error) {
	row := q.db.QueryRowContext(ctx, getStatsByTrain, trainNumber)
	var i GetStatsByTrainRow
	err := row.Scan(
		&i.TrainNumber,
		&i.Category,
		&i.OriginID,
		&i.OriginName,
		&i.DestinationID,
		&i.DestinationName,
		&i.ObservationCount,
		&i.AverageDelay,
		&i.MaxDelay,
		&i.OnTimePercentage,
	)
	return i, err
}

const getWorstStations = `-- name: GetWorstStations :many
SELECT
    station_id,
    station_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE circulation_state != 1
GROUP BY station_id
HAVING observation_count >= 3
ORDER BY average_delay DESC
LIMIT ?
`

type GetWorstStationsRow struct {
	StationID        string      `json:"station_id"`
	StationName      string      `json:"station_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetWorstStations(ctx context.Context, limit int64) ([]GetWorstStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorstStations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorstStationsRow{}
	for rows.Next() {
		var i GetWorstStationsRow
		if err := rows.Scan(
			&i.StationID,
			&i.StationName,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorstTrains = `-- name: GetWorstTrains :many
SELECT
    train_number,
    train_category as category,
    origin_id,
    origin_name,
    destination_id,
    destination_name,
    COUNT(*) as observation_count,
    COALESCE(AVG(delay), 0) as average_delay,
    COALESCE(MAX(delay), 0) as max_delay,
    SUM(CASE WHEN delay = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as on_time_percentage
FROM train_observation
WHERE circulation_state != 1
GROUP BY train_number, origin_id, destination_id
HAVING observation_count >= 3
ORDER BY average_delay DESC
LIMIT ?
`

type GetWorstTrainsRow struct {
	TrainNumber      int64       `json:"train_number"`
	Category         *string     `json:"category"`
	OriginID         *string     `json:"origin_id"`
	OriginName       *string     `json:"origin_name"`
	DestinationID    *string     `json:"destination_id"`
	DestinationName  *string     `json:"destination_name"`
	ObservationCount int64       `json:"observation_count"`
	AverageDelay     interface{} `json:"average_delay"`
	MaxDelay         interface{} `json:"max_delay"`
	OnTimePercentage int64       `json:"on_time_percentage"`
}

func (q *Queries) GetWorstTrains(ctx context.Context, limit int64) ([]GetWorstTrainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorstTrains, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorstTrainsRow{}
	for rows.Next() {
		var i GetWorstTrainsRow
		if err := rows.Scan(
			&i.TrainNumber,
			&i.Category,
			&i.OriginID,
			&i.OriginName,
			&i.DestinationID,
			&i.DestinationName,
			&i.ObservationCount,
			&i.AverageDelay,
			&i.MaxDelay,
			&i.OnTimePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertObservation = `-- name: UpsertObservation :one
INSERT INTO train_observation (id, observed_at, station_id, station_name, observation_type,
    train_number, train_category, origin_id, origin_name, destination_id, destination_name,
    scheduled_time, scheduled_date, delay, platform, circulation_state)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(train_number, station_id, observation_type, scheduled_date) DO UPDATE SET
    observed_at = excluded.observed_at,
    train_category = excluded.train_category,
    origin_id = excluded.origin_id,
    origin_name = excluded.origin_name,
    destination_id = excluded.destination_id,
    destination_name = excluded.destination_name,
    delay = excluded.delay,
    platform = excluded.platform,
    circulation_state = excluded.circulation_state
RETURNING id, delay
`

type UpsertObservationParams struct {
	ID               string     `json:"id"`
	ObservedAt       time.Time  `json:"observed_at"`
	StationID        string     `json:"station_id"`
	StationName      string     `json:"station_name"`
	ObservationType  string     `json:"observation_type"`
	TrainNumber      int64      `json:"train_number"`
	TrainCategory    *string    `json:"train_category"`
	OriginID         *string    `json:"origin_id"`
	OriginName       *string    `json:"origin_name"`
	DestinationID    *string    `json:"destination_id"`
	DestinationName  *string    `json:"destination_name"`
	ScheduledTime    *time.Time `json:"scheduled_time"`
	ScheduledDate    *string    `json:"scheduled_date"`
	Delay            *int64     `json:"delay"`
	Platform         *string    `json:"platform"`
	CirculationState *int64     `json:"circulation_state"`
}

type UpsertObservationRow struct {
	ID    string `json:"id"`
	Delay *int64 `json:"delay"`
}

func (q *Queries) UpsertObservation(ctx context.Context, arg UpsertObservationParams) (UpsertObservationRow, error) {
	row := q.db.QueryRowContext(ctx, upsertObservation,
		arg.ID,
		arg.ObservedAt,
		arg.StationID,
		arg.StationName,
		arg.ObservationType,
		arg.TrainNumber,
		arg.TrainCategory,
		arg.OriginID,
		arg.OriginName,
		arg.DestinationID,
		arg.DestinationName,
		arg.ScheduledTime,
		arg.ScheduledDate,
		arg.Delay,
		arg.Platform,
		arg.CirculationState,
	)
	var i UpsertObservationRow
	err := row.Scan(&i.ID, &i.Delay)
	return i, err
}
